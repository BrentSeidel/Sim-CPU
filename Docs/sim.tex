\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
%  Define Tiny Lisp based on Common Lisp
%
\lstdefinelanguage[Tiny]{Lisp}[]{Lisp}{morekeywords=[13]{atomp, bit-vector-p, car, cdr, char-downcase, char-code, char-upcase, compiled-function-p, dowhile, dump, exit, fresh-line, if, code-char, lambda, msg, nullp, parse-integer, peek8, peek16, peek32, poke8, poke16, poke32, progn, quote, read-line, reset, setq, simple-bit-vector-p, simple-string-p, simple-vector-p, string-downcase, string-upcase, memb, meml, memw, sim-step, go, reg-val, num-reg, halted}}
\lstset{language=Ada}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\comment}[1]{{\color{red}{#1}}}
%
\newcommand{\docname}{Users's Manual for \\ CPU Simulators}

%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\maketitle
\begin{center}
This document is \copyright 2024 Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

%========================================================
\chapter{Introduction}
This project includes simulators for some existing processors.  It can be embedded into other code as a library, or used stand-alone with a command line interpreter.  The intent of these simulators are to provide instruction level simulation and not hardware level.  Generally, no attempt has been made to count clock cycles - instructions may not even take the same relative amount of time to execute.

Interfaces are provided to allow the simulator to be controlled by and display data on a simulated control panel (see the Pi-Mainframe (\url{https://github.com/BrentSeidel/Pi-Mainframe}) project.  These may be stubbed out or ignored if not needed.

\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How To Obtain}
This package is currently available on GitHub at \url{https://github.com/BrentSeidel/Sim-CPU}

\section{Dependencies}
\subsection{Ada Libraries}
The following Ada packages are used:
\begin{itemize}
  \item \package{Ada.Calendar}
  \item \package{Ada.Characters.Latin\_1}
  \item \package{Ada.Containers.Indefinite\_Ordered\_Maps}
  \item \package{Ada.Direct\_IO}
  \item \package{Ada.Exceptions}
  \item \package{Ada.Integer\_Text\_IO}
  \item \package{Ada.Streams}
   \item \package{Ada.Strings.Fixed}
  \item \package{Ada.Strings.Maps.Constants}
  \item \package{Ada.Strings.Unbounded}
  \item \package{Ada.Text\_IO}
  \item \package{Ada.Text\_IO.Unbounded\_IO}
  \item \package{Ada.Unchecked\_Conversion}
\end{itemize}


\subsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada} or using alire via ``\keyword{alr get bbs}'' and the \package{BBS.Lisp} package available at \url{https://github.com/BrentSeidel/Ada-Lisp} or using alire via ``\keyword{alr get bbs\_lisp}''.  Packages external to this library are marked with an asterisk.
\begin{itemize}
  \item \package{BBS}*
  \item \package{BBS.lisp}*
  \item \package{BBS.lisp.evaluate}*
  \item \package{BBS.lisp.strings}*
  \item \package{BBS.Sim\_CPU}
  \item \package{BBS.Sim\_CPU.Clock}
  \item \package{BBS.Sim\_CPU.disk}
  \item \package{BBS.Sim\_CPU.Example}
  \item \package{BBS.Sim\_CPU.i8080}
  \item \package{BBS.Sim\_CPU.Lisp}
  \item \package{BBS.Sim\_CPU.m68000}
  \item \package{BBS.Sim\_CPU.m68000.line\_0}
  \item \package{BBS.Sim\_CPU.m68000.line\_1}
  \item \package{BBS.Sim\_CPU.m68000.line\_2}
  \item \package{BBS.Sim\_CPU.m68000.line\_3}
  \item \package{BBS.Sim\_CPU.m68000.line\_4}
  \item \package{BBS.Sim\_CPU.m68000.line\_5}
  \item \package{BBS.Sim\_CPU.m68000.line\_6}
  \item \package{BBS.Sim\_CPU.m68000.line\_7}
  \item \package{BBS.Sim\_CPU.m68000.line\_8}
  \item \package{BBS.Sim\_CPU.m68000.line\_9}
  \item \package{BBS.Sim\_CPU.m68000.line\_b}
  \item \package{BBS.Sim\_CPU.m68000.line\_c}
  \item \package{BBS.Sim\_CPU.m68000.line\_d}
  \item \package{BBS.Sim\_CPU.m68000.line\_e}
  \item \package{BBS.Sim\_CPU.m68000.exceptions}
  \item \package{BBS.Sim\_CPU.serial}
  \item \package{BBS.Sim\_CPU.serial.telnet}
  \item \package{BBS.Sim\_CPU.serial.mux}
  \item \package{cli}
  \item \package{cli\_parse}
  \item \package{GNAT.Sockets}*
\end{itemize}

%========================================================
\chapter{Usage Instructions}


\section{Using Alire}
Alire automatically handles dependencies.  To use this in your project, just issue the command ``\keyword{alr with bbs\_simcpu}'' in your project directory.  To build the standalone CLI program, first obtain the cli using ``\keyword{alr get simcpucli}''.  Change to the appropriate directory and use ``\keyword{alr build}'' and ``\keyword{alr run}''.  To use the load CP/M program, use ``\keyword{alr get loadcpm}''.  Change to the appropriate directory and use ``\keyword{alr build}'' and ``\keyword{alr run}''.

\section{Using \keyword{gprbuild}}
This is a library of routines intended to be used by some program.  To use these in your program, edit your *\keyword{.gpr} file to include a line to \keyword{with} the path to \keyword{bbs\_simcpu\_noalr.gpr}.  Then in your Ada code \keyword{with} in the package(s) you need and use the routines.

This is also available as a standalone program with a command line interface (CLI).  This can be used for development or debugging.  To build the CLI, just build the \keyword{simcli\_noalr.gpr} project file, after making sure that the dependencies are in the expected places.

There is another program \keyword{loadcpm} available to create a bootable CP/M floppy disk image.  It is build using the \keyword{loadcpm\_noalr.gpr} project.  It takes an Intel hex file image and writes it to a floppy disk image.

%========================================================
\chapter{API Description}
\section{General}
Several simulators are available for use.  Each simulator may also have variation.  So, one simulator may provide variations for different processors in a family of processors.

Each simulator is based on an object that derives from the \datatype{simulator} object defined in the \package{BBS.Sim\_CPU} package.  A generic simulator interface is defined with some procedures or functions that must be defined by a specific simulator and some that may be defined, if needed.  There are also a number of utility functions that are not expected to be overridden by a specific simulator.

The current design has memory included in the simulator instead of being an external device.  Any I/O decoding is also handled inside the simulator.  This means that any reading and writing of memory has to be done via routines defined by the simulator.

\subsection{Data Types}
Currently, processors with address and data busses up to 32 bits wide are supported.  For the address bus, use the data type \datatype{addr\_bus}  and for the data bus, use \datatype{data\_bus}.  These are both defined as a 32 bit unsigned integer.  Each simulator may use as many or as few of these bits as are needed.  This means that if (as in most cases) a simulator doesn't define a full 4 GB of memory, the external program can try to read or write non-existent memory.  This will probably cause an exception.

\subsection{Initialization}
This should be called once at the beginning of the host program to initialize the simulator.  The implementation is up to the simulators and it is possible that some simulators may not need any initialization.
\begin{lstlisting}
procedure init(self : in out simulator) is abstract;
\end{lstlisting}
\begin{itemize}
  \item \keyword{self} - The simulator object to initialize.
\end{itemize}

\subsection{Loading Data to Memory}
The main routines for reading and writing simulator memory are:

Called to set a memory value.
\begin{lstlisting}
procedure set_mem(self : in out simulator;
                  mem_addr : addr_bus;
                  data : data_bus) is abstract;
\end{lstlisting}
\begin{itemize}
  \item \keyword{self} - The simulator owning the memory to set.
  \item \keyword{mem\_addr} - The memory address.  This is allowed to be a 32 bit value.  The simulator itself may do range limiting or wrapping (eg. only low order 16 bits are used) internally.
  \item \keyword{data} - The data value to write into the memory address.  This is allowed to be a 32 bit value.  The simulator decides how to handle this value and what value actually gets written.
\end{itemize}
Called to read a memory value.
\begin{lstlisting}
function read_mem(self : in out simulator;
             mem_addr : addr_bus) return
  data_bus is abstract;
\end{lstlisting}
\begin{itemize}
  \item \keyword{self} - The simulator owning the memory to read.
  \item \keyword{mem\_addr} - The memory address.  This is allowed to be a 32 bit value.  The simulator itself may do range limiting or wrapping (eg. only low order 16 bits are used) internally.
  \item Returns the value of memory at the specified memory address.
\end{itemize}
The actual addressing and data bus used are defined by the specific simulator.

For loading bulk data into memory use:
\begin{lstlisting}
procedure load(self : in out simulator; name : String)
   is null;
\end{lstlisting}
Its implementation is defined by the simulator.  Typically it loads an Intel Hex file or Motorola S-Record file representing a memory image.

\subsection{Running a Simulation}
The \function{start} procedure is called first to specify a starting address for program execution.  This is called to start simulator execution at a specific address.  This is made null rather than abstract so that simulators that don't use it don't need to override it.
\begin{lstlisting}
procedure start(self : in out simulator; addr : addr_bus) is null;
\end{lstlisting}
Then, each instruction is individually executed using the \function{run} procedure.  This is called once per frame when start/stop is in the start position and run/pause is in the run position.
\begin{lstlisting}
procedure run(self : in out simulator) is abstract;
\end{lstlisting}
Certain conditions or instruction can cause a simulator to halt.  The \function{halted} and \function{continue\_proc} routines can be used to test for this condition and clear it.

Check if simulator is halted.  If a simulator doesn't define this, it will return \constant{False}.
\begin{lstlisting}
function halted(self : in out simulator) return Boolean is (False);
\end{lstlisting}
This clears the halted flag allowing processing to continue.  If a simulator doesn't define this, it has no action.
\begin{lstlisting}
procedure continue_proc(self : in out simulator) is null;
\end{lstlisting}
From all of this, one can write the core of a simulator as follows:
\begin{lstlisting}
--
--  A bunch of other stuff including defining some
--  simulator as "sim"
--
begin
   sim.init;
   --
   --  I/O devices can be added here...
   --
   sim.load("image.hex");
   sim.start(0);  --  Start execution at address 0
   while not sim.halted loop
      sim.run;
   end loop;
end
\end{lstlisting}

\subsection{Variants}
Each simulator can support variants.  This enables one simulator to support multiple CPUs in a family.  Since the variants supported are unique to each simulator a universal data type cannot be used.  Variants are identified by a \datatype{Natural} number.  The following routines are used to get the number of variants supported by a simulator, the name of each variant, the currently selected variant, and to select a variant:

Called to get number of variants.  This defaults to returning one if the simulator doesn't define an alternative.
\begin{lstlisting}
function variants(self : in out simulator) return Natural is (1);
\end{lstlisting}
Called to get variant name.  This needs to be overridden by the simulator.
\begin{lstlisting}
function variant(self : in out simulator; v : Natural)
   return String is abstract;
\end{lstlisting}
Called to get current variant index.  This needs to be overridden by the simulator.
\begin{lstlisting}
function variant(self : in out simulator) return Natural is abstract;
\end{lstlisting}
Called to set variant.  This needs to be overridden by the simulator.
\begin{lstlisting}
procedure variant(self : in out simulator; v : Natural) is abstract;
\end{lstlisting}

\subsection{Other}
A number of other functions are defined to support I/O devices, interfaces with a front panel, and other things.  The I/O support routines will be discussed more in chapter \ref{chap:IODev} on I/O devices.
%--------------------------------------------------------------------------------------------------
\section{Example}
The example simulator provides an example of using the simulator object interface.  Its primary purpose is to blink the lights in interesting ways in the Pi-Mainframe (\url{https://github.com/BrentSeidel/Pi-Mainframe}) project.  There are a number of different patterns selectable.  Variants are defined for ``Copy Switches'', ``Count'', ``16-Bit Scan'', ``16-Bit Bouncer'', ``Fibonacci Counter'', ``32-Bit Scan'', and ``32-Bit Bouncer''.

This simulator is unusual in that it has no memory defined, but instead has several registers defined that act as memory.  When reading or writing memory, the address is ignored and the value returned depends on the pattern (variant) selected.

%--------------------------------------------------------------------------------------------------
\section{8080 Family}
The 8080 simulator has variants defined for the 8080, 8085, and Z-80 processors.  These are 8 bit processors with an 8 bit data bus and a 16 bit address bus.  In addition to a memory bus, these processors also include an I/O bus with 8 bit I/O port addressing.  See \cite{i8080} for more information about the 8080/8085.  See \cite{z80} and \cite{z80undoc} for more information about the Z-80.

Currently, the 8080 family does not have memory mapped I/O.  This may be added at some time in the future.

When loading data using the \function{load} routine, the specified file is assumed to be in Intel Hex format.

%--------------------------------------------------------------------------------------------------
\section{68000 Family}
The 68000 simulator has variants defined for the 68000, 68008, 68010, and CPU32.  Only the 68000 and 68008 are currently implemented.  The 68010 and CPU32 are for future development.  Internally, these are 32 bit processors with 32 bit data and 32 bit address busses.  The external address and data bus sizes depend on the variant selected.  See \cite{m68000a} and \cite{m68000b} for more information about the 68000 family.

The interrupt code is interpreted with the low order bits (7-0) representing the vector number and the next 8 bits (15-8) representing the priority.  Interrupts with vectors that match internally defined exception vectors are ignored.  Thus only interrupt vectors in the range 25-31 and 64-255 are processed.

When loading data using the \function{load} routine, the specified file is assumed to be in Motorola S-Record format.

%--------------------------------------------------------------------------------------------------
\section{6502 Family}
The 6502 simulator currently has only a working variants defined for the 6502 processor.  This is an 8 bit processors with an 8 bit data bus and a 16 bit address bus.  This processor does not have a separate I/O address space.  All I/O is mapped as part of the main memory.  Three interrupts are define for normal interrupts, non-maskable interrupts, and reset.  See \cite{msc6502} for more information about the 6502.

When loading data using the \function{load} routine, the specified file is assumed to be in Intel Hex format.

%========================================================
\chapter{I/O Devices}
\label{chap:IODev}
Each I/O device is based on an object that derives from the \datatype{io\_device} object defined in the \package{BBS.Sim\_CPU} package.  A generic I/O device interface is defined with some procedures or functions that must be defined by a specific I/O device and some that may be defined, if needed.  There are also a number of utility functions that are not expected to be overridden by a specific I/O device.

To be used by a simulator, an I/O device must first be attached to the simulator using the \function{attach\_io} routine.  This is called to attach an I/O device to a simulator at a specific address.  Bus is simulator dependent as some CPUs have separate I/O and memory space.
\begin{lstlisting}
procedure attach_io(self : in out simulator;
                    io_dev : io_access;
                    base_addr : addr_bus;
                    bus : bus_type) is abstract;
\end{lstlisting}

Many of the I/O devices will have an initialization routine specific for that device.  Since this may have device specific parameters, it can't be defined as part of the \datatype{io\_device} object.

Along with attaching the I/O device to the simulator, the base address needs to be set in the I/O device object.  The value for \keyword{base} in this routine should match the value for \keyword{base\_addr} in the \function{attach\_io} routine.  Bad things may happen if they don't match.
\begin{lstlisting}
procedure setBase(self : in out io_device;
                  base : addr_bus) is abstract;
\end{lstlisting}

The I/O device \verb|read| and \verb|write| functions are called by the simulator when an address within the devices address range is accessed.  Note that the address range starts at the \verb|base_addr| specified in the \verb|attach_io| call and extends through the number of addresses specified in the \verb|getSize| function.  If needed, the simulator can query the I/O device for its base address using the \verb|getBase| function.  If a device needs to do DMA or interrupt a simulator, the \verb|setOwner| procedure must be called first to give the device a reference to the simulator.  For interrupts, the \verb|setException| routine is used to define a \verb|long| value that the device passes to the simulator on exception.
\begin{lstlisting}
procedure setException(self : in out io_device;
                       except : long);
\end{lstlisting}

If a device does not use interrupts, this routine can be declared as \verb|null|.

%--------------------------------------------------------------------------------------------------
\section{Clock}
The main function of the clock device is to provide a periodic interrupt.  It can be enabled or disabled and the time between interrupts can be set in $\frac{1}{10}$th of a second.  The base time can be changed by editing the code.  Note that the timing is only approximate and depends on many things.  Also since the simulation is not running at the same speed as actual hardware the number of instructions between each interrupt will be different from actual hardware.

%--------------------------------------------------------------------------------------------------
\section{Serial Ports}
Serial ports provide a way to provide a terminal interface to a simulator.  Unlike real serial ports, output buffering is done by the host operating system and it is not obvious to the I/O device if the output has been completed or not.  As a result, currently no status is set or interrupts generated on output.  The output is assumed to complete instantly.

\subsection{Basic Serial Port}
The basic serial port was developed in early testing to send output to and get input from the terminal controlling the simulator.  It worked well enough to test some initial concepts, but has been superseded by the single line telnet port.

\subsection{Single Line Telnet Port}
The single line telnet port provides a replacement for the basic serial port.  This device has an \verb|init| routine that is used to set the TCP port.  Using \verb|telnet| to connect to this port connects to the device and will allow communication with software running on the simulator.  If enabled, this device can provide interrupts to the simulator when characters are received.

\subsection{Multi-Line Telnet Port}
The multi-line telnet port combines 8 ports into a single simulated device.  The \verb|init| routine specifies the starting TCP port.  It and the next seven ports can be accessed by \verb|telnet| to communicate with software running on the simulator.  This uses a single exception and requires fewer addresses than having 8 single line telnet ports.

\subsection{Tape}
The ``paper'' tape interface is based on a serial port.  From the point of view of the host program, it reads bytes and writes bytes.  The read bytes come from an attached file and the written bytes are written to an attached file (note that the should be two different files).  One could also imagine this as a cassette tape interface if that better fits the computer you're simulating.

%--------------------------------------------------------------------------------------------------
\section{Disk Interfaces}
The initial \verb|disk_ctrl| device was designed with 8 inch floppy disks in mind for use by CP/M.  It has been extended to allow other disk geometries, but follows the model of tracks, sectors per track, and heads for defining a disk.  It currently supports 16 bit DMA, but may be extended to support 32 bit DMA.  All data transfers occur between the request and the next instruction processed by the simulator.

A \verb|hd_ctrl| device is under development that will support a simpler model.  Disks are simply a linear sequence of blocks.  It will support 32 bit block addressing and 32 bit DMA.

%========================================================
\chapter{Command Line Interface}
The command line interface first requests which simulator to use.  The choices are currently 8080 and 68000.  This will change as more simulators are added.  Depending on which simulator is selected, a number of I/O devices are attached to the simulator.  Currently, changing this will require editing and rebuilding the program.
%--------------------------------------------------------------------------------------------------
\section{Device Names}
Each device has a name that can be used to refer to it.  The name consists of an alphabetic device code followed by a decimal unit number.  If no unit number is specified, 0 is assumed.  A unit number of zero is special.  It is used to refer to a generic device, such as when attaching a device - the unit number is assigned during the attachment.
The currently defined device codes are (note that not all are implemented in the CLI, but will eventually be):
\begin{description}
  \item[CLK] -- A clock device to generate a periodic interrupt.
  \item[CON] -- A console serial device.  In most cases, this should not be used.
  \item[FD] -- Main disk controller with a track and sector interface.  It started out as a floppy disk controller, but geometries can be defined beyond that.
  \item[HD] -- An experimental disk controller using just block numbers.  It is not yet implemented and tested.
  \item[MUX] -- An 8 channel terminal multiplexer using a telnet interface.
  \item[PRN] -- A simple printer output device.
  \item[PTP] -- A paper tape interface.  It can read and write simulated tapes.
  \item[TEL] -- A single channel terminal device using a telnet interface.
\end{description}
%--------------------------------------------------------------------------------------------------
\section{Commands}
A number of commands are provided to allow the user to run and interact with software running on the simulator.  The commands and their exact operation may change depending on feedback from usage.
\begin{description}
  \item[;] -- A comment.  Everything following on the line is ignored, except if the rest of the line is being used as a file name.
  \item[ATTACH $<$device$>$ $<$addr$>$ $<$bus$>$ [$<$dev-specific$>$]] --  Attaches a specific I/O device at the bus address.  Depending on the device, device specific parameters may be required.
  \item[BREAK $<$addr$>$] -- Sets a breakpoint at the specified address.
  \item[CONTINUE] -- Clear a simulation halted condition.  This can be abbreviated to \verb|C|.
  \item[CPU $<$cpu-name$>$] -- Set the CPU to be simulated.  This can only be done once per session and must be done before any command that requires a CPU.
  \item[DEP $<$addr$>$ $<$byte$>$] -- Deposit a byte into memory.
  \item[DISK]  --  Commands related to floppy disks and image files (see below for more details).
  \item[DUMP $<$addr$>$] -- Dump a block of memory starting at the specified address.  This can be abbreviated to \verb|D|.
  \item[EXIT] -- Exit the simulation (synonym for \verb|QUIT|).
  \item[GO $<$addr$>$] -- Sets the execution address.
  \item[INTERRUPT]-- Can be abbreviated to \verb|INT|.  Used to enable or disable interrupt processing by the simulated CPU.
  \item[LISP [$<$filename$>$]] -- Starts the Tiny-Lisp environment.  If a filename is specified, Lisp commands come from that file.
  \item[LIST [$<$devname$>$]] -- Lists all the I/O devices attached to the simulator.  If $<$devname$>$ is supplied, it provides information for that specific device.
  \item[LOAD $<$filename$>$] -- Loads memory with the specified file (typically Intel Hex or S-Record format).
  \item[TAPE] -- Commands relating to printer and attached file (see below for more details).
  \item[QUIT] -- Exit the simulation (synonym for \verb|EXIT|).
  \item[REG] -- Display the registers and their contents.
  \item[RESET] -- Calls the simulator's \verb|init| routine.
  \item[RUN] -- Runs the simulator.  While running, it can be interrupted by a control-E character.  This can be abbreviated to \verb|R|.
  \item[STEP] -- Execute a single instruction, if the simulation is not halted.
  \item[TAPE] -- Commands relating to paper (or cassette) tape and attached files (see below for more details).
  \item[TRACE $<$value$>$] -- Sets the trace value.  The value is interpreted by the simulator and typically causes certain information to be printed while processing.
  \item[UNBREAK $<$addr$>$] -- Clears a breakpoint at the specified address.  For some simulators, the address is ignored and may not need to be specified.  In this case, all or the only breakpoint is cleared.
\end{description}

\subsection{Attach Command}
\label{cli:Attach}
The attach command is used to attach a device to the current CPU simulator.  The device is specified as a generic device name.  The address is given in decimal.  The bus is:
\begin{description}
  \item[IO] -- Use the I/O bus (only available on some CPUs).
  \item[MEM] -- Use memory mapped I/O (only available on some CPUs).
\end{description}
Some of the devices take additional parameters.
\begin{description}
  \item[CLK] -- Takes one additional decimal value for the exception code to be presented to the CPU when an interrupt occurs.
  \item[FD] -- Takes one additional decimal parameter for the number of attached drives in the range 0-15, though 0 drives is rather pointless.
  \item[HD] -- Not yet implemented for ATTACH (experimental - under development).
  \item[MUX] -- Takes two additional decimal parameters.  The first is the TCP/IP port for the first terminal (the additional terminals are assigned sequential port numbers).  The second is the exception code to be presented to the CPU when an interrupt occurs.
  \item[PRN] -- Takes no additional parameters..
  \item[PTP] -- Takes no additional parameters.
  \item[TEL] --  Takes two additional decimal parameters.  The first is the TCP/IP port for the first terminal (the additional terminals are assigned sequential port numbers).  The second is the exception code to be presented to the CPU when an interrupt occurs.
\end{description}

\subsection{CPU Command}
The CPU command takes the name of a CPU to simulate.  The following are valid CPU names:  ``8080''. ``8085'', ``Z80'', ``68000'', ``68008'', and ``6502''.

\subsection{Disk Commands}
A number of subcommands are available for interfacing with simulated floppy disks and image files.  The DISK command takes the form:
\begin{itemize}
  \item DISK $<$controller$>$ $<$subcommand$>$ $<$parameters for subcommand$>$
\end{itemize}
The controller is the device name of an attached disk controller.  The subcommands are:
\begin{description}
  \item[CLOSE $<$drive number$>$] -- Closes the image file associated with the specified drive number.
  \item[OPEN $<$drive number$>$ $<$file name$>$] -- Attaches the specified file to the specified drive.
  \item[READONLY $<$drive number$>$] -- Sets the specified drive to read-only.
  \item[READWRITE $<$drive number$>$] -- Sets the specified drive to read-write.
\end{description}

\subsection{Interrupt Commands}
A number of subcommands are available for interfacing with interrupts.
\begin{description}
  \item[ON] -- Enables interrupt processing by the simulator (if supported).
  \item[OFF] -- Disables interrupt processing by the simulator.  This may be useful for single-stepping through some code without getting interrupted by the clock or other devices.
  \item[SEND $<$interrupt number$>$] --  Sends the specified interrupt number to the simulator (if supported).
\end{description}

\subsection{Tape Commands}
The tape interface consists of a reader called \verb|RDR| and a writer called \verb|PUN| (for punch).  Files can be opened or closed for either of these devices.   The TAPE command takes the form:
\begin{itemize}
  \item TAPE $<$controller$>$ $<$subcommand$>$ $<$parameters for subcommand$>$
\end{itemize}
The controller is the device name of an attached tape controller.  The subcommands are:
\begin{description}
  \item[CLOSE $<$PUN or RDR$>$]  -- Closes the file attached to the reader or punch.
  \item[OPEN $<$PUN or RDR$>$ $<$file name$>$] --  Attaches the specified file to the reader or punch.
\end{description}

\subsection{Printer Commands}
The printer device simply writes data sent to it to an output file.  If no file is open, the data is discarded.   The PRINT command takes the form:
\begin{itemize}
  \item PRINT $<$controller$>$ $<$subcommand$>$ $<$parameters for subcommand$>$
\end{itemize}
The controller is the device name of an attached printer controller.  The subcommands are:
\begin{description}
  \item[CLOSE]  -- Closes the file attached to the printer.
  \item[OPEN  $<$file name$>$] --  Attaches the specified file to the printer.
\end{description}


%--------------------------------------------------------------------------------------------------
\section{Lisp Programming}
The Lisp environment is based on Ada-Lisp, available at \url{https://github.com/BrentSeidel/Ada-Lisp}, with a few commands added to interface with a simulator.  Refer to the Ada-Lisp documentation for details about the core language.  This section just describes the additional commands.

\subsection{Attach}
\subsubsection{Inputs}
The following inputs are expected:
\begin{itemize}
  \item A string representing the device name.
  \item An integer for the device address.
  \item A string representing the address bus used (``IO'' or ``MEM'').
  \item Additional items specific to the device may be required.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Attaches an I/O device at the specified address and address bus.  Refer to the Attach command (section \ref{cli:Attach}) for more information.

\subsection{Disk-Close}
The following inputs are expected:
\begin{itemize}
  \item A string representing the disk controller name.
  \item An integer for the drive number.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Closes the file attached to the specified disk drive.

\subsection{Disk-Geom}
The following inputs are expected:
\begin{itemize}
  \item A string representing the disk controller name.
  \item An integer for the drive number.
  \item A string representing the geometry (currently ``IBM'' for 8 inch diskettes or ``HD'' for a 5MB hard disk).  It is planned to extend this to allow a list specifying arbitrary geometry as well.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Sets the disk geometry (tracks, sectors, heads) of the specified disk drive.

\subsection{Disk-Open}
The following inputs are expected:
\begin{itemize}
  \item A string representing the disk controller name.
  \item An integer for the drive number.
  \item A string representing the file name to attach to the disk drive.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Opens a file and attaches it to the specified disk drive.

\subsection{Go}
\subsubsection{Inputs}
A number representing the starting address for program execution.
\subsubsection{Outputs}
None
\subsubsection{Description}
Sets the starting address for program execution.  The next \verb|(sim-step)| command executes the instruction at this location.

\subsection{Halted}
\subsubsection{Inputs}
An optional boolean that if set true, clears the halted state of the simulator.  If set false, does nothing.
\subsubsection{Outputs}
If no input is provided, it returns a boolean representing the halted state, 
\subsubsection{Description}
This is used to clear to test the halted state of a simulator.

\subsection{Int-state}
\subsubsection{Inputs}
None
\subsubsection{Outputs}
A simulator dependent integer representing the state of interrupts.
\subsubsection{Description}
Returns a simulator dependent integer representing the state of the interrupts.  Typically it is something like 0 for interrupts disabled and 1 for interrupts enabled.  For systems with priorities, it may be the processor priority.

\subsection{Last-out-addr}
\subsubsection{Inputs}
None
\subsubsection{Outputs}
The address used by the last output instruction.
\subsubsection{Description}
Returns the address used by the last output instruction.  This is only meaningful if the processor being simulated has a separate output bus rather than memory mapped I/O.

\subsection{Last-out-data}
\subsubsection{Inputs}
None
\subsubsection{Outputs}
The data used by the last output instruction.
\subsubsection{Description}
The data used by the last output instruction.  This is only meaningful if the processor being simulated has a separate output bus rather than memory mapped I/O.

\subsection{Memb}
\subsubsection{Inputs}
A memory address and an optional byte value.
\subsubsection{Outputs}
If no byte value is provided, it returns the byte at the memory address.
\subsubsection{Description}
Reads or writes a byte value in memory.

\subsection{Meml}
\subsubsection{Inputs}
A memory address and an optional long value.
\subsubsection{Outputs}
If no long value is provided, it returns the long at the memory address.
\subsubsection{Description}
Reads or writes a long value in memory.

\subsection{Memw}
\subsubsection{Inputs}
A memory address and an optional word value.
\subsubsection{Outputs}
If no word value is provided, it returns the word at the memory address.
\subsubsection{Description}
Reads or writes a word value in memory.

\subsection{Num-reg}
\subsubsection{Inputs}
None
\subsubsection{Outputs}
The number of registers defined by the simulator.
\subsubsection{Description}
Returns the number of registers defined by the simulator.  This could be used for iterating through the registers and displaying their values.

\subsection{Override-in}
\subsubsection{Inputs}
Two integers representing the address of an I/O port and the data to provide.
\subsubsection{Outputs}
None
\subsubsection{Description}
Provides an address and data to override the next input instruction.  If the instruction reads from the address, the provided data is read by the simulator instead of reading from the actual I/O device.  Inputs from a different address work normally and any input instruction clears the override.  This is intended for testing purposes.

\subsection{Print-Close}
The following inputs are expected:
\begin{itemize}
  \item A string representing the printer controller name.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Closes the file attached to the specified printer.

\subsection{Print-Open}
The following inputs are expected:
\begin{itemize}
  \item A string representing the printer controller name.
  \item A string representing the file name to attach to the printer.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Opens a file and attaches it to the specified printer.

\subsection{Reg-val}
\subsubsection{Inputs}
A register number
\subsubsection{Outputs}
The value of the specified register, or an error if the register number is not in range.
\subsubsection{Description}
Returns the value of the specified register.

\subsection{Send-int}
\subsubsection{Inputs}
An integer interrupt code.
\subsubsection{Outputs}
None.
\subsubsection{Description}
Sends the specified interrupt code to the simulator for processing.  The processing done depends on the specific simulator.  It may be ignored, be a vector number, be an instruction, or something else.

\subsection{Sim-CPU}
\subsubsection{Inputs}
A string containing the CPU name.  The following are valid CPU names:  ``8080''. ``8085'', ``Z80'', ``68000'', ``68008'', and ``6502''.
\subsubsection{Outputs}
None
\subsubsection{Description}
Selects the CPU to simulate.  This can only be done once and must be done before any command that attempts to access the CPU.

\subsection{Sim-init}
\subsubsection{Inputs}
None.
\subsubsection{Outputs}
None.
\subsubsection{Description}
Calls the initialization routine to the current simulator.  The action is simulator dependent, but typically clears the registers.  The memory may, or may not be cleared.

\subsection{Sim-load}
\subsubsection{Inputs}
A string containing a file name.
\subsubsection{Outputs}
None.
\subsubsection{Description}
Calls the load routine for the current simulator and passes the string containing the file name.  The effect is simulator dependent, but the 8080 simulator will attempt to load the file as an Intel hex format file and the 68000 simulator will attempt to load the file as a Motorola S-record file.

\subsection{Sim-step}
\subsubsection{Inputs}
None.
\subsubsection{Outputs}
None.
\subsubsection{Description}
Executes one instruction or step of the simulator.

\subsection{Tape-Close}
The following inputs are expected:
\begin{itemize}
  \item A string representing the tape controller name.
  \item A string representing the output (``PUN'' for punch) or input (``RDR'' for reader).
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Closes the file attached to the specified tape drive unit.

\subsection{Tape-Open}
The following inputs are expected:
\begin{itemize}
  \item A string representing the tape controller name.
  \item A string representing the output (``PUN'' for punch) or input (``RDR'' for reader).
  \item A string representing the file name to attach to the tape drive.
\end{itemize}
\subsubsection{Outputs}
None
\subsubsection{Description}
Opens a file and attaches it to the specified tape drive unit.

\subsection{Examples}
The Lisp environment is useful for writing automated tests and for writing utilities to enhance the CLI.
\subsubsection{Watch a Memory Location}
The following Lisp program will execute instructions until the specified memory location changes.
\lstset{language=[Tiny]Lisp}
\begin{lstlisting}
(defun watch (addr)
  (setq old-value (meml addr))
  (dowhile (= old-value (meml addr))
    (sim-step)))
\end{lstlisting}

%========================================================
\clearpage
\addcontentsline{toc}{chapter}{Bibleography}
\nocite{m68000a}
\nocite{m68000b}
\nocite{i8080}
\bibliographystyle{plain}
\bibliography{sim.bib}

\end{document}

