RXSTAT = 177560   ; Receiver status register
RXDATA = 177562   ; Receiver data register
TXSTAT = 177564   ; Transmitter status resister
TXDATA = 177566   ; Transmitter data register
INTRE = 100       ; Interrupt enable bit
READY = 200       ; Device ready bit

         .PSECT VECT,ABS
.=60
RXVECT:  .WORD 1     ;  PC for receive interrupt
         .WORD 2     ;  PSW
TXVECT:  .WORD PISR  ;  PC for transmit interrupt
         .WORD 0     ;  PSW

         .PSECT CODE,ABS
.=1000
;
;  Print message using polled TX
;
START:   MOV #TOP,SP
         MOV #MSG1,@#TXTPTR
         MOV #MSG1LEN,@#TXTCNT
         JSR PC,@#SEND
;
;  Echo input using polled RX/TX
;
ECHO:    JSR PC,GETCP
         JSR PC,PUTCP
         CMPB #'A,R2
         BNE ECHO
;
         MOV #MSG2,@#TXTPTR
         MOV #MSG2LEN,@#TXTCNT
         JSR PC,@#SENDI
;
EXIT:    HALT
;
;  Section containing data
;
         .PSECT DATA,ABS
.=2000
TXTPTR:  .BLKW 1     ; Pointer for text to send
TXTCNT:  .BLKW 1     ; Count of remaining text

MSG1:    .ASCII /Hello world sent using polling./<15><12>
MSG1LEN = . - MSG1
;
MSG2:    .ASCII /Hello world sent using interrupts./<15><12>
MSG2LEN = . - MSG2
;
;  Section for stack.  This should be ample.
;
         .PSECT STACK,ABS
.=3000
         .BLKW 1000
TOP:
;
;  Subroutines go here so that they aren't relocated everytime code is
;  added to the main program.
;
         .PSEC SUBR,ABS
.=5000
;
;  Send text to the console using polling.  Entered with:
;  TXTPTR - Point to start of string
;  TXTCNT - Number of characters to send.
;
;  On exit:
;  TXTPTR - Points one past end of string
;  TXTCNT - Set to zero.
;
SEND:    MOV @#TXPTR,R0
         MOV @#TXCNT,R1
         BEQ 1$      ; Exit if nothing to print

2$:      MOVB (R0)+,R2
         JSR PC, @#PUTCP
         DEC R1
         BEQ 1$      ; Exit when count is zero
         BR 2$       ; Next character

1$:      MOV R0,@#TXPTR
         MOV R1,@#TXCNT
         RTS PC
;
;  Put character polled.  Called with character in the low byte of R2.
;
PUTCP:   BIT @#TXSTAT,#READY
         BEQ PUTCP      ; Busy wait until TX ready
         MOVB R2,@#TXDATA
         RTS PC
;
;  Get character polled.  Returns the character in the low byte of R2.
;
GETCP:   BIT @#RXSTAT,#READY
         BEQ GETCP      ; Busy wait until RX ready
         MOVB @#RXDATA,R2
         RTS PC
;
;  Send text to the console using interrupts.  Entered with:
;  TXTPTR - Point to start of string
;  TXTCNT - Number of characters to send.
;
;  On exit:
;  TXTPTR - Points one past end of string
;  TXTCNT - Set to zero.
;
SENDI:   BIT @#TXSTAT,#READY
         BEQ SENDI            ; Wait for TX to be ready before starting
         BIS #INTRE,@#TXSTAT  ; Enable interrupts
         MOV @#TXPTR,R0
         MOV @#TXCNT,R1
2$:      BEQ 1$               ; Exit if nothing to print
         MOVB (R0)+,R2
         DEC R1
         MOV R0,@#TXPTR
         MOV R1,@#TXCNT
         MOVB R2,@#TXDATA     ; Send the first character out
3$:      WAIT
         TST @#TXCNT
         BNE 3$
1$:      RTS PC
;
; Interrupt service routine to send a character.
;
PISR:    MOV R0,-(SP)
         MOV R1,-(SP)
         MOV R2,-(SP)
         MOV @#TXPTR,R0
         MOV @#TXCNT,R1
         BEQ 1$               ; If no new character to send, exit
         MOVB (R0)+,R2
         DEC R1
         MOV R0,@#TXPTR
         MOV R1,@#TXCNT
         MOVB R2,@#TXDATA
1$:      MOV (SP)+,R2
         MOV (SP)+,R1
         MOV (SP)+,R0
         RTI
         .END START
